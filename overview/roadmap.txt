🚀 Phase 1 – Project Foundation
Monorepo & Tooling

Initialize a pnpm/Turbo monorepo.

Add top-level ESLint, Prettier, and EditorConfig.

Create folders: apps/frontend, apps/backend, apps/ai, infra, docs, tests.

Version Control & CI/CD

Initialize Git, push to your repo.

Add GitHub Actions (or preferred) workflows for lint/tests.

Configure Dockerfiles & a docker-compose.yml stub.

Infrastructure as Code

Scaffold Terraform modules for:

VPC & network

Kubernetes or container hosts

Managed Postgres & Redis

Store secrets in your chosen vault/secret manager.

🎨 Phase 2 – Frontend Shell & Auth
Next.js App Setup

npx create-next-app apps/frontend --ts --app.

Install Tailwind, ShadCN/UI, Framer Motion.

Auth Integration

Add Clerk (or Auth0):

Protect routes, create login/signup pages.

Expose user context via React hook.

Global UI Components

Navbar with logo, auth status, theme toggle.

Footer with links (“About,” “Privacy,” etc.).

Dark/light mode via Tailwind CSS.

Landing Split-Screen Layout

Left panel: “Talk to the AI Therapist” call-to-action.

Right panel: “Join a Social Space” call-to-action.

Add fade-in animations on load.

🤖 Phase 3 – AI Therapist MVP
Chat Interface

Chat window component: message list + text input.

Message bubble styles (user vs. AI).

Backend Endpoint

/api/ai/message on Fastify (TS) or FastAPI (Python).

Proxy requests to Hugging Face Inference for MelloGPT-GGUF.

Session Context

Generate a session ID per chat.

Store last N messages in memory or Redis.

Voice Input & Output

Client-side Whisper integration for speech-to-text.

Send transcribed text to /api/ai/message.

Receive AI text → call ElevenLabs TTS → play audio.

Error Handling & Loading States

Show loader while waiting.

Gracefully handle inference errors.

🔊 Phase 4 – Real-Time Audio Spaces MVP
LiveKit Service

Provision LiveKit (self-host or cloud).

Create backend token-generation endpoint /api/livekit/token.

Room UI

Join/create room flows.

Participants list, mute/unmute, leave button.

Anonymous Identity

Generate pseudonyms (e.g., “Bright Otter”) for guests.

Tie real user IDs only after login.

Basic Moderation Hooks

Emit events on join/leave for analytics.

Mute all / remove participant via admin UI.

🗄️ Phase 5 – Backend & Data Persistence
Database Schema

Tables: users, sessions, messages, rooms, tokens.

Prisma models (or SQLAlchemy) matching above.

API Layer

Auth middleware for protected routes.

CRUD endpoints for chat/session history.

Room registration & history retention if needed.

Caching & Queues

Redis for: session memory, LiveKit presence, rate limits.

Celery or BullMQ for background TTS jobs.

Vector Embeddings (Phase 5+ Ready)

Define pipeline to embed chat turns via LangChain.

Store in Pinecone/Weaviate for RAG.

🧪 Phase 6 – Testing, Monitoring & Security
Automated Testing

Unit tests: Jest (frontend/backend), Pytest (AI service).

E2E tests: Playwright for login, chat, room flows.

Error Tracking & Logs

Integrate Sentry in frontend and backend.

Centralize logs (e.g., Logflare, Datadog).

Analytics

PostHog or Plausible: track pageviews, button clicks, usage funnels.

Security Hardening

Enforce HTTPS/TLS everywhere.

Audit dependencies (npm audit / pip-audit).

Implement rate limiting and input validation.

📦 Phase 7 – Deployment & Maintenance
Container Builds

Configure production Docker images for each service.

Push to your container registry.

Orchestration

Deploy frontend to Vercel.

Deploy backend & AI microservice to Railway/Render/Fly.

Connect managed Postgres & Redis.

Smoke Tests & Rollback

Post-deploy health checks.

Automated rollback on failure.

Documentation

API docs (Swagger/OpenAPI).

Architecture diagrams in docs/.

Onboard guide: “How to run locally,” “How to code a new feature.”

